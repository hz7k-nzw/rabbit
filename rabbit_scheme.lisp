;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; This code was generated by concatenating the following files:
;;;
;;; scheme.lisp -- LISP code for the SCHEME interpreter
;;; by Gerald Jay Sussman and Guy Lewis Steele, Jr.,
;;; with the code for macro by Darius Bacon (http://wry.me/),
;;; which is not included in the original paper.
;;;
;;; trampoline.lisp -- LISP code for RABBIT-compiled code driver
;;; by Darius Bacon (http://wry.me/)
;;;
;;; Concatenated by Kenji Nozawa
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(DECLARE (SPECIAL **EXP** **UNEVLIS** **ENV** **EVLIS** **PC** **CLINK** **VAL**
		  **TEM** **TOP** **QUEUE** **TICK** **PROCESS** **QUANTUM**
		  VERSION LISPVERSION))

;;-- For RABBIT
(DECLARE (SPECIAL **fun** **cont** **nargs** ;also **env** but that's in interpreter too
		  **one** **two** **three** **four** **five** **six** **seven** **eight**))

(DEFUN SCHEME ()
  ;;--(SETQ VERSION (VERSION) LISPVERSION (STATUS LISPVERSION))
  (setq version "xxx" lispversion "yyy")
  (TERPRI)
  (PRINC '|This is SCHEME |)
  (PRINC VERSION)
  (PRINC '| running in LISP |)
  (PRINC LISPVERSION)
  (SETQ **ENV** NIL **QUEUE** NIL
	**PROCESS** (CREATE!PROCESS '(**TOP** '|SCHEME -- Toplevel|)))
  (SWAPINPROCESS)
  ;;--(ALARMCLOCK 'RUNTIME **QUANTUM**)
  (MLOOP))

(SETQ **TOP**
      '(BETA (LAMBDA (**MESSAGE**)
	       (LABELS ((**TOP1**
			 (LAMBDA (**IGNORE1** **IGNORE2** **IGNORE3**)
			   (**TOP1** (TERPRI) (PRINC '|==> |)
				     ;;--(PRINT (SET '* (EVALUATE (READ))))))))
				     (print (evaluate (read)))))))
		 (**TOP1** (TERPRI)
			   (PRINC **MESSAGE**)
			   NIL)))
	     NIL))

(DEFUN SETTICK (X) (SETQ **TICK** T))

(SETQ **QUANTUM** 1000000. ALARMCLOCK 'SETTICK)

(DEFUN MLOOP ()
  ;;--(DO ((**TICK** NIL)) (NIL) ; DO forever
  (do ((**tick** t)) (nil) ; do forever
;    (dump 'in-mloop)
    (AND **TICK** (ALLOW) (SCHEDULE))
    (FASTCALL **PC**)))

(DEFUN FASTCALL (ATSYM)
  ;;--(COND ((EQ (CAR (CDR ATSYM)) 'SUBR)
  (cond ((eq (car (plist atsym)) 'subr)
	 ;;--(SUBRCALL NIL (CADR (CDR ATSYM))))
	 (subrcall nil (cadr (plist atsym))))
	(T ((LAMBDA (SUBR)
	      (COND (SUBR (REMPROP ATSYM 'SUBR)
			  (PUTPROP ATSYM SUBR 'SUBR)
			  (SUBRCALL NIL SUBR))
		    (T (FUNCALL ATSYM))))
	    (GET ATSYM 'SUBR)))))

(DEFUN ALLOW ()
  ((LAMBDA (VCELL)
     (COND (VCELL (CADR VCELL))
	   (T T)))
   (ASSQ '*ALLOW* **ENV**)))

(DEFUN SCHEDULE ()
  (COND (**QUEUE**
	 (SWAPOUTPROCESS)
	 (NCONC **QUEUE** (LIST **PROCESS**))
	 (SETQ **PROCESS** (CAR **QUEUE**)
	       **QUEUE** (CDR **QUEUE**))
	 (SWAPINPROCESS)))
  (SETQ **TICK** NIL)
  (ALARMCLOCK 'RUNTIME **QUANTUM**))

(DEFUN SWAPOUTPROCESS ()
  ((LAMBDA (**CLINK**)
     (PUTPROP **PROCESS** (SAVEUP **PC**) 'CLINK)
     (PUTPROP **PROCESS** **VAL** 'VAL)
     ;;-- For RABBIT
     (putprop **process** **fun** 'fun)
     (putprop **process** **cont** 'cont)
     (putprop **process** **nargs** 'nargs)
     (putprop **process** **one** 'one)
     (putprop **process** **two** 'two)
     (putprop **process** **three** 'three)
     (putprop **process** **four** 'four)
     (putprop **process** **five** 'five)
     (putprop **process** **six** 'six)
     (putprop **process** **seven** 'seven)
     (putprop **process** **eight** 'eight))
   **CLINK**))

(DEFUN SWAPINPROCESS ()
  (SETQ **CLINK** (GET **PROCESS** 'CLINK)
	**VAL** (GET **PROCESS** 'VAL)
	;;-- For RABBIT
	**fun** (get **process** 'fun)
	**cont** (get **process** 'cont)
	**nargs** (get **process** 'nargs)
	**one** (get **process** 'one)
	**two** (get **process** 'two)
	**three** (get **process** 'three)
	**four** (get **process** 'four)
	**five** (get **process** 'five)
	**six** (get **process** 'six)
	**seven** (get **process** 'seven)
	**eight** (get **process** 'eight))
  (RESTORE))

(DEFUN PRIMOP (X) (GETL X '(SUBR EXPR LSUBR)))

(DEFUN SAVEUP (RETAG)
  (SETQ **CLINK** (LIST **EXP** **UNEVLIS** **ENV**
			**EVLIS** RETAG **CLINK**)))

(DEFUN RESTORE ()
  (PROG (TEMP)
	(SETQ TEMP (OR **CLINK**
		       (ERROR '|PROCESS RAN OUT - RESTORE|
			      **EXP**
			      'FAIL-ACT))
	      **EXP** (CAR TEMP)
	      TEMP (CDR TEMP)
	      **UNEVLIS** (CAR TEMP)
	      TEMP (CDR TEMP)
	      **ENV** (CAR TEMP)
	      TEMP (CDR TEMP)
	      **EVLIS** (CAR TEMP)
	      TEMP (CDR TEMP)
	      **PC** (CAR TEMP)
	      TEMP (CDR TEMP)
	      **CLINK** (CAR TEMP))))

(defun aeval ()
  (cond ((atom **exp**)
	 (cond ((numberp **exp**)
		(setq **val** **exp**)
		(restore))
	       ;;-- accepts string as atom
	       ((stringp **exp**)
		(setq **val** **exp**)
		(restore))
	       ;;-- accepts character as atom
	       ((characterp **exp**)
		(setq **val** **exp**)
		(restore))
	       ;;-- look up lex env before checking lisp primop
	       ;;-- (scheme operator may override lisp primop)
	       ((setq **tem** (assq **exp** **env**))
		(setq **val** (cadr **tem**))
		(restore))
	       ;;-- look up global env before checking lisp primop
	       ;;-- (scheme operator may override lisp primop)
	       ((boundp **exp**)
		(setq **val** (symeval **exp**))
		(restore))
	       ;;-- look up lisp primop
	       ((primop **exp**)
		(setq **val** **exp**)
		(restore))
	       (t (error '|BAD ATOM - AEVAL| **exp** 'fail-act))))
	((atom (car **exp**))
	 (cond ((setq **tem** (get (car **exp**) 'aint))
		(setq **pc** **tem**))
	       ((eq (car **exp**) 'lambda)
		(setq **val** (list 'beta **exp** **env**))
		(restore))
	       ;;-- expand macro defined via schmac
	       ((setq **tem** (get (car **exp**) 'amacro))
		(setq **exp** (funcall **tem** **exp**)))
	       ;;-- expand macro defined via defmac or defmacro
	       ((setq **tem** (get (car **exp**) 'macro))
		(setq **exp** (macroexpand **exp**)))
	       ;;-- eval lisp fsubr (defun, defmacro, declare, ...)
	       ((setq **tem** (or (get (car **exp**) 'fsubr)
				  (get (car **exp**) 'fexpr)))
		(setq **val** (funcall **tem** (cdr **exp**)))
		(restore))
	       (t (setq **evlis** nil
			**unevlis** **exp**
			**pc** 'evlis))))
	((eq (caar **exp**) 'lambda)
	 (setq **evlis** (list (car **exp**))
	       **unevlis** (cdr **exp**)
	       **pc** 'evlis))
	(t (setq **evlis** nil
		 **unevlis** **exp**
		 **pc** 'evlis))))

(DEFUN EVLIS ()
  (COND ((NULL **UNEVLIS**)
	 (SETQ **EVLIS** (REVERSE **EVLIS**))
	 (COND ((ATOM (CAR **EVLIS**))
		(SETQ **VAL** (APPLY (CAR **EVLIS**) (CDR **EVLIS**)))
		(RESTORE))
	       ((EQ (CAAR **EVLIS**) 'LAMBDA)
		(SETQ **ENV** (PAIRLIS (CADAR **EVLIS**)
				       (CDR **EVLIS**)
				       **ENV**)
		      **EXP** (CADDAR **EVLIS**)
		      **PC** 'AEVAL))
	       ((EQ (CAAR **EVLIS**) 'BETA)
		(SETQ **ENV** (PAIRLIS (CADR (CADAR **EVLIS**))
				       (CDR **EVLIS**)
				       (CADDAR **EVLIS**))
		      **EXP** (CADDR (CADAR **EVLIS**))
		      **PC** 'AEVAL))
	       ((EQ (CAAR **EVLIS**) 'DELTA)
		(SETQ **CLINK** (CADAR **EVLIS**))
		(RESTORE))
	       ;;-- For RABBIT
	       ((eq (caar **evlis**) 'cbeta)
		(pack-argument-registers (cdr **evlis**))
		(setq **fun** (car **evlis**)
		      **cont** (interpreted->compiled-cont **clink**)
		      **pc** 'trampoline))
	       (T (ERROR '|BAD FUNCTION - EVARGLIST| **EXP** 'FAIL-ACT))))
	(T (SAVEUP 'EVLIS1)
	   (SETQ **EXP** (CAR **UNEVLIS**)
		 **PC** 'AEVAL))))

(DEFUN EVLIS1 ()
  (SETQ **EVLIS** (CONS **VAL** **EVLIS**)
	**UNEVLIS** (CDR **UNEVLIS**)
	**PC** 'EVLIS))

(DEFPROP EVALUATE EVALUATE AINT)

(DEFUN EVALUATE ()
  (SAVEUP 'EVALUATE1)
  (SETQ **EXP** (CADR **EXP**)
	**PC** 'AEVAL))

(DEFUN EVALUATE1 ()
  (SETQ **EXP** **VAL**
	**PC** 'AEVAL))

(DEFPROP IF IF AINT)

(DEFUN IF ()
  (SAVEUP 'IF1)
  (SETQ **EXP** (CADR **EXP**)
	**PC** 'AEVAL))

(DEFUN IF1 ()
  (COND (**VAL** (SETQ **EXP** (CADDR **EXP**)))
	(T (SETQ **EXP** (CADDDR **EXP**))))
  (SETQ **PC** 'AEVAL))

(DEFPROP QUOTE AQUOTE AINT)

(DEFUN AQUOTE ()
  (SETQ **VAL** (CADR **EXP**))
  (RESTORE))

(DEFPROP LABELS LABELS AINT)

(DEFUN LABELS ()
  (SETQ **TEM** (MAPCAR '(LAMBDA (DEF)
			   (LIST (CAR DEF)
				 (LIST 'BETA (CADR DEF) NIL)))
			(CADR **EXP**)))
  (MAPC '(LAMBDA (VC)
	   (RPLACA (CDDADR VC) **TEM**))
	**TEM**)
  (SETQ **ENV** (NCONC **TEM** **ENV**)
	**EXP** (CADDR **EXP**)
	**PC** 'AEVAL))

(DEFUN CREATE!PROCESS (EXP)
  ((LAMBDA (**PROCESS** **EXP** **ENV** **UNEVLIS** **EVLIS** **PC** **CLINK** **VAL**
	    **fun** **cont** **nargs**
	    **one** **two** **three** **four** **five** **six** **seven** **eight**)
     (SWAPOUTPROCESS)
     **PROCESS**)
   (GENSYM)
   EXP
   **ENV**
   NIL
   NIL
   'AEVAL
   (LIST NIL NIL NIL NIL 'TERMINATE NIL)
   NIL
   nil nil nil
   nil nil nil nil nil nil nil nil))

(DEFUN START!PROCESS (P)
  (COND ((OR (NOT (ATOM P)) (NOT (GET P 'CLINK)))
	 (ERROR '|BAD PROCESS -- START!PROCESS| **EXP** 'FAIL-ACT)))
  (OR (EQ P **PROCESS**) (MEMQ P **QUEUE**)
      (SETQ **QUEUE** (NCONC **QUEUE** (LIST P))))
  P)

(DEFUN STOP!PROCESS (P)
  (COND ((MEMQ P **QUEUE**)
	 (SETQ **QUEUE** (DELQ P **QUEUE**)))
	((EQ P **PROCESS**) (TERMINATE)))
  P)

(DEFUN TERMINATE ()
  (COND ((NULL **QUEUE**)
	 (SETQ **PROCESS**
	       (CREATE!PROCESS '(**TOP** '|RABBIT-SCHEME -- Queueout|))))
	(T (SETQ **PROCESS** (CAR **QUEUE**)
		 **QUEUE** (CDR **QUEUE**))))
  (SETQ **CLINK** (GET **PROCESS** 'CLINK))
  (SETQ **VAL** (GET **PROCESS** 'VAL))
  ;;-- For RABBIT
  (setq **fun** (get **process** 'fun))
  (setq **cont** (get **process** 'cont))
  (setq **nargs** (get **process** 'nargs))
  (setq **one** (get **process** 'one))
  (setq **two** (get **process** 'two))
  (setq **three** (get **process** 'three))
  (setq **four** (get **process** 'four))
  (setq **five** (get **process** 'five))
  (setq **six** (get **process** 'six))
  (setq **seven** (get **process** 'seven))
  (setq **eight** (get **process** 'eight))
  'TERMINATE-VALUE)

(DEFPROP EVALUATE!UNINTERRUPTIBLY EVALUATE!UNINTERRUPTIBLY AINT)

(DEFUN EVALUATE!UNINTERRUPTIBLY ()
  (SETQ **ENV** (CONS (LIST '*ALLOW* NIL) **ENV**)
	**EXP** (CADR **EXP**)
	**PC** 'AEVAL))

(DEFPROP DEFINE DEFINE AINT)

(DEFUN DEFINE ()
  (SET (CADR **EXP**) (LIST 'BETA (CADDR **EXP**) NIL))
  (SETQ **VAL** (CADR **EXP**))
  (RESTORE))

(DEFUN ASET (VAR VALU)
  (SETQ **TEM** (ASSQ VAR **ENV**))
  (COND (**TEM** (RPLACA (CDR **TEM**) VALU))
	(T (SET VAR VALU)))
  VALU)

(DEFPROP CATCH ACATCH AINT)

(DEFUN ACATCH ()
  (SETQ **ENV** (CONS (LIST (CADR **EXP**) (LIST 'DELTA **CLINK**)) **ENV**)
	**EXP** (CADDR **EXP**)
	**PC** 'AEVAL))

(DEFUN PAIRLIS (X Y Z)
  (DO ((I X (CDR I))
       (J Y (CDR J))
       (L Z (CONS (LIST (CAR I) (CAR J)) L)))
      ((AND (NULL I) (NULL J)) L)
    (AND (OR (NULL I) (NULL J))
	 (ERROR '|WRONG NUMBER OF ARGUMENTS - PAIRLIS|
		**EXP**
		'WRNG-NO-ARGS))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Macro stuff implemented by Darius Bacon
;;; http://wry.me/
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Macro stuff not implemented in the original Scheme paper:

;;--(eval-when (:execute :compile-toplevel :load-toplevel)
(eval-when (eval compile load)
  ;;--(defmacro defmac (name params &body body)
  (defmacro define-schmac (name params &body body)
    (let ((subject (gensym)))
      `(putprop ',name
		#'(lambda (,subject)
		    (destructuring-bind ,params (cdr ,subject)
		      ,@body))
		'amacro))))

; Think this is buggy but it's currently unused:
;;--(defmac let (pairs exp)
;;--  `((lambda ,(mapcar 'car pairs) ,exp)
;;--    ,@(mapcar 'cadr pairs)))
(define-schmac let (pairs . body)
  `((lambda ,(mapcar 'car pairs) (block ,@body))
    ,@(mapcar 'cadr pairs)))

;;--(defmac and args
(define-schmac and args
  (cond ((null (cdr args)) (car args))
	(t `(if ,(car args)
		(and ,@(cdr args))
	        nil))))

;;--(defmac or args
(define-schmac or args
  (cond ((null (cdr args)) (car args))
	(t `((lambda (x p) (if x x (p)))
	     ,(car args)
	     (lambda () (or ,@(cdr args)))))))

;;--(defmac block (exp . exps)
;;--  (cond ((null exps) exp)
;;--	(t `((lambda (x p) (p))
;;--	     ,exp
;;--	     (lambda () (block ,@exps))))))
(define-schmac block args
  (cond ((null args) nil)
	((null (cdr args)) (car args))
	(t `((lambda (x p) (p))
	     ,(car args)
	     (lambda () (block ,@(cdr args)))))))

;;--(defmac cond clauses
(define-schmac cond clauses
  (cond ((null clauses) nil)
	(t `(if ,(caar clauses)
		(block ,@(cdar clauses))
	        (cond ,@(cdr clauses))))))

;;--(defmac do (iters exit . body)
(define-schmac do (iters exit . body)
  (let ((vars (mapcar 'car iters))
	(inits (mapcar 'cadr iters))
	(steps (mapcar 'caddr iters))
	(done (car exit))
	(result (cdr exit))
	(repeat (gensym)))
    `(labels ((,repeat
	       (lambda (,(gensym) ,@vars)
		 (if ,done 
		     (block ,@result)
		     (,repeat (block ,@body) ,@steps)))))
       (,repeat nil ,@inits))))

;;--(defparameter amapcar
(defvar amapcar
  '(beta (lambda (f xs) 
	   (if (null xs)
	       '()
	       (cons (f (car xs))
		     (amapcar f (cdr xs)))))
	 nil))

;;--(defparameter amaplist
(defvar amaplist
  '(beta (lambda (f xs) 
	   (if (null xs)
	       '()
	       (cons (f xs)
		     (amaplist f (cdr xs)))))
	 nil))

; I added this function for convenience:
;;--(defparameter aload
(defvar aload
  '(beta (lambda (filename)
	   ((lambda (port)
	      (labels ((loop 
			(lambda (input)
			  (if input
			      (block (evaluate input)
			             (loop (read port nil)))))))
		(block (loop (read port nil))
		       (close port))))
	    (open filename)))
	 nil))

; TODO: we'll need an APPLY function eventually

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Code added by Kenji Nozawa
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;(defprop defmac defmac aint)
;;
;;(defun defmac ()
;;  (eval `(defmacro ,(cadr **exp**) ,(caddr **exp**) ,@(cdddr **exp**)))
;;  (setq **val** (cadr **exp**))
;;  (restore))
(putprop 'defmac (get 'defmacro 'fsubr) 'fsubr)

(putprop 'progn (get 'block 'amacro) 'amacro)

(defprop schmac schmac aint)

(defun schmac ()
  ;; How can I define schmac without using EVAL?
  (eval `(define-schmac ,(cadr **exp**) ,(caddr **exp**) ,@(cdddr **exp**)))
  (setq **val** (cadr **exp**))
  (restore))

(defprop proclaim proclaim aint)

(defun proclaim ()
  (setq **val** 'proclaim)
  (restore))

(defvar amapc
  '(beta (lambda (f xs)
	   (if (null xs)
	       '()
	       (block (f (car xs))
	         (amapc f (cdr xs)))))
	 nil))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ENCLOSE was originally included in trampoline.lisp by Darius
;;; Bacon, and moved here for better classification
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; The need for this came up when trying to get RABBIT to compile itself.
;; (When it tried to handle a PROCLAIM form.)
(defvar enclose
  '(beta (lambda (lambda-exp)
           ;; XXX I dunno if this is just what ENCLOSE is supposed to do.
           ;; But something like this...
           (list 'beta lambda-exp nil))
         nil))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Code from trampoline.lisp by Darius Bacon
;;; http://wry.me/
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Convenience function for running code through RABBIT.
(defvar compile-and-load
  '(beta (lambda (fname)
           (block
             (comfile fname)              ;from rabbit.scm
             (terpri)
             (compile-file (java:string-replace-first fname "\\.scm" ".lisp"))
             (format t "~A compiled~%" (java:string-replace-first fname "\\.scm" ".lisp"))
             (load (java:string-replace-first fname "\\.scm" ".fasl"))
             (format t "~A loaded~%" (java:string-replace-first fname "\\.scm" ".fasl"))
             T))
         nil))

(defun bounce-off ()
  (*throw 'bounce-off **one**))

(defun jump-onto-trampoline (fun args)
  "Execute the equivalent of (apply fun args) on the trampoline and return the result."
  (setq **fun** fun
        **cont** (list 'cbeta #'bounce-off))
  (pack-argument-registers args)
  (*catch 'bounce-off (trampoline)))

(defun trampoline ()
  "Top-level loop running Scheme code (compiled or interpreted)."
  (do () ((not **fun**))
;    (dump 'in-trampoline)
    (cond
     ((listp **fun**)
      (cond ((eq 'cbeta (car **fun**))
             (setq **env** (cddr **fun**))
             (funcall (cadr **fun**)))
            ((eq 'beta (car **fun**))
             (let ((lambda-exp (cadr **fun**))
                   (environment (caddr **fun**)))
               (let ((parameters (cadr lambda-exp))
                     (body (caddr lambda-exp)))
                 (setq **exp** body
                       **env** (pairlis parameters (unpack-argument-registers) environment)
                       **pc** 'aeval
                       **clink** (compiled->interpreted-cont **cont**)
                       **fun** nil)))) ; return to mloop
            ((eq (car **fun**) 'delta)
             (setq **clink** (cadr **fun**)
                   **val** **one**
                   **fun** nil) ; return to mloop
             (restore))
            (T (ERROR '|BAD FUNCTION - TRAMPOLINE| **FUN** 'FAIL-ACT))))
     ((subrp **fun**) ; Does this detect LSUBRs too? I'm not sure.
      (setq **one**
            (cond
             ;; For speed, we SUBRCALL in common cases, rather than APPLY:
             ;; (except actually we use FUNCALL for now)
             ((= 0 **nargs**) (funcall **fun**))
             ((= 1 **nargs**) (funcall **fun** **one**))
             ((= 2 **nargs**) (funcall **fun** **one** **two**))
             ((= 3 **nargs**) (funcall **fun** **one** **two** **three**))
             (t (apply **fun** (unpack-argument-registers))))
            **fun** **cont**))
     ((exprp **fun**)
      (setq **one** (apply **fun** (unpack-argument-registers))
            **fun** **cont**))
     (t (ERROR '|BAD FUNCTION - TRAMPOLINE| **FUN** 'FAIL-ACT)))))

(defun dump (tag)
  (print '****)
  (princ tag)
  (print (list 'fun **fun**))
  (print (list 'cont **cont**))
  (print (list 'nargs **nargs**))
  (print (list 'one **one**))
  (print (list 'pc **pc**))
  (print (list 'clink **clink**))
  (print (list 'exp **exp**))
  (print (list 'val **val**))
  (print '----)
;  (print 'press-return)
;  (read-line)
  )

(defun unpack-argument-registers ()
  (cond
   ((= 0 **nargs**) (list))
   ((= 1 **nargs**) (list **one**))
   ((= 2 **nargs**) (list **one** **two**))
   ((= 3 **nargs**) (list **one** **two** **three**))
   ((= 4 **nargs**) (list **one** **two** **three** **four**))
   ((= 5 **nargs**) (list **one** **two** **three** **four** **five**))
   ((= 6 **nargs**) (list **one** **two** **three** **four** **five** **six**))
   ((= 7 **nargs**) (list **one** **two** **three** **four** **five** **six** **seven**))
   ((= 8 **nargs**) (list **one** **two** **three** **four** **five** **six** **seven** **eight**))
   (t **one**)))

(defun pack-argument-registers (args)
  (setq **nargs** (length args))
  (cond ((< 8 **nargs**)
         (setq **one** args))
        (t (when args (setq **one**   (car args) args (cdr args)))
           (when args (setq **two**   (car args) args (cdr args)))
           (when args (setq **three** (car args) args (cdr args)))
           (when args (setq **four**  (car args) args (cdr args)))
           (when args (setq **five**  (car args) args (cdr args)))
           (when args (setq **six**   (car args) args (cdr args)))
           (when args (setq **seven** (car args) args (cdr args)))
           (when args (setq **eight** (car args))))))

(defun compiled->interpreted-cont (cont)
  "Return a continuation representation appropriate for **clink**, 
given one appropriate for **cont**."
  ;(LIST **EXP** **UNEVLIS** **ENV** **EVLIS** RETAG **CLINK**)
  (list nil nil nil nil 'return-to-trampoline cont))

(defun return-to-trampoline ()
  (setq **fun** **clink**
        **one** **val**
        **pc** 'trampoline))

(defun return-to-interpreter ()
  (setq **fun** nil)
  (setq **clink** **env**)
  (restore)
  (setq **val** **one**))

(defun interpreted->compiled-cont (clink)
  "Return a continuation representation appropriate for **cont**, 
given one appropriate for **clink**."
  (list* 'cbeta #'return-to-interpreter clink))

